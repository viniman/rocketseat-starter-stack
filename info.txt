yarn init

possibilidade de trabalhar com a interface de linha de comando do babel:
yarn add @babel/cli

yarn add @babel/preset-env


Arquivo de configuração do babel:
.babelrc


yarn add @babel/core




yarn dev



-w : automatico, vai ficar monitorando
"dev": "babel ./main.js -o ./bundle.js -w"



rest/spread
yarn add @babel/plugin-proposal-object-rest-spread



yarn dev


REST -> pegar o resto das outras variaveis ...resto



-> webpack
yarn add webpack webpack-cli -D


Criar webpack.config.js: Arquivo principal de configuração do webpack


yarn add babel-loader -D


Executar o webpack: yarn dev


pode ter um export default e vários exports sem default


pasta src: todos arquivos que o webpack precisa monitorar
public: que nao precisa monitorar



yarn add webpack-dev-server -D



Comando para colocar ele na web em servidor:
"build": "webpack --mode=production" -> comando para produção

Trabalhar com o nosso projeto offline: o dev server dá um refresh automaticamente na página
"dev": "webpack-dev-server --mode=development",


Biblioteca para trabalhar com async/await: deixa o código muito mais limpo
- Não precisa código com muito callback, utilizando cascata com then e catch


yarn add @babel/plugin-transform-async-to-generator -D
yarn add @babel/polyfill -D


-D : instala como dependencia de desenvolvimento


Quando usa async function, automaticamente ela vira uma promise

Só consegue usar o await se estiver dentro de uma função com async







Biblioteca Axios: trabalhar com uma Biblioteca com requisições assincronas
yarn add axios -> não é dependencia de desenvolvimento entao nao precisa do -D

axios.get e todas as funcoes do axios retornam promises









------------------------------------
           CURSO NODE
------------------------------------

npm init -y

vai criar package.json : guarda dependencias

npm install express : micro framework para lidar com rotas e views

package-lock.json : apenas para cash - saber quais dependencias estao instaladas

node server.js

req = todas as informações sobre a requisição
res = resposta que vai dar para o cliente/navegador


npm install -D nodemon
Nodemon: faz reinicialização do servidor quando alterar alguma coisa no código do servidor

package.json devDependences(-D): dependencias usadas apenas no ambiente de desenvolvimento


"dev": "nodemon server.js"
Agora roda com: npm run dev




------------------------------------
         MONGO DB | DOCKER
------------------------------------


install docker
https://docs.docker.com/engine/install/ubuntu/


install mongo db on docker
docker pull mongo

Subir uma nova máquina virtual/container contendo essa instalação rodando
docker run --name mongodb -p 27017:27017 -d mongo

-p :redirecionamento de porta (pois o conteiner será uma outra máquina)
Ao acessar a porta 27017 da máquina, vai acessar a porta 27017 do container do mongodb
27017: porta padrão do mongodb
-d: qual imagem quero utilizar

docker ps: quais imagens estão rodando

Utilizar Robo3T
https://robomongo.org/

Imagens docker que estão pausadas, não estão rodando/online
docker ps -a (vai retornar all)


Apenas executar (não precisa dar run novamente)
docker start mongo



Dependencia de produção
Mongoose: ORM de bancos não relacionais com o mongodb
ORM Encapsula a lógica das operações do BD através do código
Em vez de usar SQL, sempre vai usar apenas códigos javascripts pra fazer os SQL
ORM: Object-relational mapping: Mapeamento objeto-relacional
npm install mongoose


Se tiver usuário e senha
mongoose.connect('mongodb://user:password@localhost:27017/nodeapi');



Require dos models
Fazer require automático em todos os arquivos de um diretório
npm install require-dir